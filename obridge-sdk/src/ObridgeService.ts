import crypto from "crypto";
import {
    Connection,
    Keypair,
    PublicKey,
    SystemProgram,
    Transaction,
} from "@solana/web3.js";
import {
    Program,
    Idl,
    AnchorProvider,
    setProvider,
    Wallet,
    BN
} from "@coral-xyz/anchor";
import {
    getAssociatedTokenAddressSync,
    ASSOCIATED_TOKEN_PROGRAM_ID
} from "@solana/spl-token";
import { keccak_256 } from "@noble/hashes/sha3";
import { serialize, deserialize } from "v8";
import * as idl from "../Idl/obridge.json"
import Monitor from "./Monitor";

export type Lock = {
    hash: Array<number>
    deadline: BN
}

export type ExtraData = {
    dstChainId: string
    dstAddress: string
    dstToken: string
    dstAmount: string
    requestor: string
    lpId: string
    userSign: string
    lpSign: string
}

export class ObridgeService {
    connection: Connection;
    payer: Keypair;
    program: Program;
    obridgeProgramId: PublicKey;

    constructor(connection: Connection, payer: Keypair, obridgeProgramId: PublicKey, enableMonitor: boolean = false) {
        this.connection = connection;
        this.payer = payer;

        let wallet = new Wallet(this.payer);
        let provider = new AnchorProvider(this.connection, wallet, {});
        setProvider(provider);

        this.obridgeProgramId = obridgeProgramId;
        this.program = new Program(idl as Idl, this.obridgeProgramId);

        if (enableMonitor) {
            let monitor = new Monitor(this);
            monitor.init().then(() => {
                monitor.start();
            });
        }
    }

    // generate random bytes, used for generating a random UUID if len is 16
    getRandomBytes(len: number): number[] {
        let _uuid = new Uint8Array(len);
        return Array.from(crypto.getRandomValues(_uuid));
    }

    // get the hash lock by preimage
    getHashLock(preimage: number[]): number[] {
        return Array.from(keccak_256(Buffer.from(preimage)));
    }

    // get the current on-chain timestamp in seconds
    async getCurOnChainTimestamp(): Promise<number | null> {
        let slot = await this.connection.getSlot();
        let ts = await this.connection.getBlockTime(slot);
        return ts;
    }

    // get the escrow account address by uuid offchain
    getEscrowAccountAddress(uuid: number[]): PublicKey {
        let [escrow,] = PublicKey.findProgramAddressSync([Buffer.from(uuid)], this.obridgeProgramId);
        return escrow;
    }

    // get the escrow ata token address by escrow and mint offchain
    getEscrowAtaTokenAddress(escrow: PublicKey, mint: PublicKey): PublicKey {
        return getAssociatedTokenAddressSync(mint, escrow, true);
    }

    encodeExtraData(extraData: ExtraData): Buffer {
        return serialize(extraData);
    }

    decodeExtraData(extraDataBuffer: Buffer): ExtraData {
        return deserialize(extraDataBuffer);
    }

    async sendTransaction(rawTx: string, signers: Keypair[]): Promise<string> {
        let recoveredTransaction = Transaction.from(
            Buffer.from(rawTx, 'hex')
        );

        recoveredTransaction.sign(...signers);

        let signature = await this.connection.sendRawTransaction(recoveredTransaction.serialize());
        return signature;
    }

    /*
      user send a SPL token to escrow account, token transfered from user's token account to escrow's token account
      - uuid identify the swap, should be unique and generated by getRandomBytes
      - lp should be the lp's PublicKey of the swap
      - from should be the user's account and source should be the user's token account of the SPL token
      - use getEscrowAccountAddress and getEscrowAtaTokenAddress to get the escrow and escrowAta offchain
      - mint and tokenProgramId should able to identify the SPL token
    */
    async transferOut(
        uuid: number[],
        lp: PublicKey,
        amount: BN,
        userLock: Lock,
        relayLock: Lock,
        transferOutDeadline: BN,
        refundDeadline: BN,
        extraData: ExtraData,
        from: PublicKey,
        source: PublicKey,
        escrow: PublicKey,
        escrowAta: PublicKey,
        mint: PublicKey,
        tokenProgramId: PublicKey
    ): Promise<string> {
        let tx = await this.program.methods
            .initiate(
                uuid,
                lp,
                amount,
                userLock,
                relayLock,
                transferOutDeadline,
                refundDeadline,
                this.encodeExtraData(extraData)
            )
            .accounts({
                payer: this.payer.publicKey,
                from: from,
                mint: mint,
                source: source,
                escrow: escrow,
                escrowAta: escrowAta,
                associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
                systemProgram: SystemProgram.programId,
                tokenProgram: tokenProgramId,
            })
            .transaction();
        const blockHash = (await this.connection.getLatestBlockhash('finalized')).blockhash;
        tx.recentBlockhash = blockHash;
        tx.feePayer = this.payer.publicKey;
        return tx.serialize({
            requireAllSignatures: false,
            verifySignatures: true
        }).toString("hex");
    }

    /*
      lp send a SPL token to escrow account, token transfered from lp's token account to escrow's token account
      - uuid identify the swap, should be unique and generated by getRandomBytes
      - user should be the user's PublicKey of the swap
      - from should be the lp's account and source should be the lp's token account of the SPL token
      - use getEscrowAccountAddress and getEscrowAtaTokenAddress to get the escrow and escrowAta offchain
      - mint and tokenProgramId should able to identify the SPL token
    */
    async transferIn(
        uuid: number[],
        user: PublicKey,
        amount: BN,
        lpLock: Lock,
        transferInDeadline: BN,
        refundDeadline: BN,
        from: PublicKey,
        source: PublicKey,
        escrow: PublicKey,
        escrowAta: PublicKey,
        mint: PublicKey,
        tokenProgramId: PublicKey
    ): Promise<string> {
        let tx = await this.program.methods
            .initiate(
                uuid,
                user,
                amount,
                lpLock,
                null,
                transferInDeadline,
                refundDeadline,
                Buffer.from([])
            )
            .accounts({
                payer: this.payer.publicKey,
                from: from,
                mint: mint,
                source: source,
                escrow: escrow,
                escrowAta: escrowAta,
                associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
                systemProgram: SystemProgram.programId,
                tokenProgram: tokenProgramId,
            })
            .transaction();
        const blockHash = (await this.connection.getLatestBlockhash('finalized')).blockhash;
        tx.recentBlockhash = blockHash;
        tx.feePayer = this.payer.publicKey;
        return tx.serialize({
            requireAllSignatures: false,
            verifySignatures: true
        }).toString("hex");
    }

    /*
      user confirm the transferOut, the SPL token transfered from the escrow account to lp's token account
      - uuid should be the same with the uuid used in transferOut
      - preimage is the preimage of the hash lock defined in transferOut
      - destination should be the lp's token account of the SPL token
      - tokenProgramId is the token program id of the SPL token
    */
    async confirmTransferOut(
        uuid: number[],
        preimage: number[],
        destination: PublicKey,
        escrow: PublicKey,
        escrowAta: PublicKey,
        tokenProgramId: PublicKey
    ): Promise<string> {
        let tx = await this.program.methods
            .confirm(
                uuid,
                preimage
            )
            .accounts({
                destination: destination,
                escrow: escrow,
                escrowAta: escrowAta,
                systemProgram: SystemProgram.programId,
                tokenProgram: tokenProgramId,
            })
            .transaction();
        const blockHash = (await this.connection.getLatestBlockhash('finalized')).blockhash;
        tx.recentBlockhash = blockHash;
        tx.feePayer = this.payer.publicKey;
        return tx.serialize({
            requireAllSignatures: false,
            verifySignatures: true
        }).toString("hex");
    }

    /*
      lp confirm the transferIn, the SPL token transfered from the escrow account to user's token account
      - uuid should be the same with the uuid used in transferIn
      - preimage is the preimage of the hash lock defined in transferIn
      - destination should be the user's token account of the SPL token
      - tokenProgramId is the token program id of the SPL token
    */
    async confirmTransferIn(
        uuid: number[],
        preimage: number[],
        destination: PublicKey,
        escrow: PublicKey,
        escrowAta: PublicKey,
        tokenProgramId: PublicKey
    ): Promise<string> {
        let tx = await this.program.methods
            .confirm(
                uuid,
                preimage
            )
            .accounts({
                destination: destination,
                escrow: escrow,
                escrowAta: escrowAta,
                systemProgram: SystemProgram.programId,
                tokenProgram: tokenProgramId,
            })
            .transaction();
        const blockHash = (await this.connection.getLatestBlockhash('finalized')).blockhash;
        tx.recentBlockhash = blockHash;
        tx.feePayer = this.payer.publicKey;
        return tx.serialize({
            requireAllSignatures: false,
            verifySignatures: true
        }).toString("hex");
    }

    /*
      user refund the transferOut, the SPL token transfered from the escrow account to user's token account
      - uuid should be the same with the uuid used in transferOut
      - source should be the user's token account of the SPL token
      - tokenProgramId is the token program id of the SPL token
    */
    async refundTransferOut(
        uuid: number[],
        source: PublicKey,
        escrow: PublicKey,
        escrowAta: PublicKey,
        tokenProgramId: PublicKey
    ): Promise<string> {
        let tx = await this.program.methods
            .refund(
                uuid
            )
            .accounts({
                source: source,
                escrow: escrow,
                escrowAta: escrowAta,
                systemProgram: SystemProgram.programId,
                tokenProgram: tokenProgramId,
            })
            .transaction();
        const blockHash = (await this.connection.getLatestBlockhash('finalized')).blockhash;
        tx.recentBlockhash = blockHash;
        tx.feePayer = this.payer.publicKey;
        return tx.serialize({
            requireAllSignatures: false,
            verifySignatures: true
        }).toString("hex");
    }

    /*
      lp refund the transferIn, the SPL token transfered from the escrow account to lp's token account
      - uuid should be the same with the uuid used in transferIn
      - source should be the lp's token account of the SPL token
      - tokenProgramId is the token program id of the SPL token
    */
    async refundTransferIn(
        uuid: number[],
        source: PublicKey,
        escrow: PublicKey,
        escrowAta: PublicKey,
        tokenProgramId: PublicKey
    ): Promise<string> {
        let tx = await this.program.methods
            .refund(
                uuid
            )
            .accounts({
                source: source,
                escrow: escrow,
                escrowAta: escrowAta,
                systemProgram: SystemProgram.programId,
                tokenProgram: tokenProgramId,
            })
            .transaction();
        const blockHash = (await this.connection.getLatestBlockhash('finalized')).blockhash;
        tx.recentBlockhash = blockHash;
        tx.feePayer = this.payer.publicKey;
        return tx.serialize({
            requireAllSignatures: false,
            verifySignatures: true
        }).toString("hex");
    }
}