import crypto from "crypto";
import {
    Connection,
    Keypair,
    PublicKey,
    SystemProgram
} from "@solana/web3.js";
import {
    Program,
    Idl,
    AnchorProvider,
    setProvider,
    Wallet,
    BN
} from "@coral-xyz/anchor";
import {
    getAssociatedTokenAddressSync,
    ASSOCIATED_TOKEN_PROGRAM_ID
} from "@solana/spl-token";
import { keccak_256 } from "@noble/hashes/sha3";
import * as idl from "../Idl/obridge.json"

export type Lock = {
    hash: Array<number>
    deadline: BN
}

export class ObridgeService {
    connection: Connection;
    payer: Keypair;
    program: Program;
    obridgeProgramId: PublicKey;

    constructor(connection: Connection, payer: Keypair, obridgeProgramId: PublicKey) {
        this.connection = connection;
        this.payer = payer;

        let wallet = new Wallet(this.payer);
        let provider = new AnchorProvider(this.connection, wallet, {
            commitment: 'confirmed',
        });
        setProvider(provider);

        this.obridgeProgramId = obridgeProgramId;
        this.program = new Program(idl as Idl, this.obridgeProgramId);
    }

    // generate random bytes, used for generating a random UUID if len is 16
    getRandomBytes(len: number): number[] {
        let _uuid = new Uint8Array(len);
        return Array.from(crypto.getRandomValues(_uuid));
    }

    // get the hash lock by preimage
    getHashLock(preimage: number[]): number[] {
        return Array.from(keccak_256(Buffer.from(preimage)));
    }

    // get the current on-chain timestamp in seconds
    async getCurOnChainTimestamp(): Promise<number | null> {
        let slot = await this.connection.getSlot();
        let ts = await this.connection.getBlockTime(slot);
        return ts;
    }

    // get the escrow account address by uuid offchain
    getEscrowAccountAddress(uuid: number[]): PublicKey {
        let [escrow,] = PublicKey.findProgramAddressSync([Buffer.from(uuid)], this.obridgeProgramId);
        return escrow;
    }

    // get the escrow ata token address by escrow and mint offchain
    getEscrowAtaTokenAddress(escrow: PublicKey, mint: PublicKey): PublicKey {
        return getAssociatedTokenAddressSync(mint, escrow, true);
    }

    /*
      user send a SPL token to escrow account, token transfered from user's token account to escrow's token account
      - uuid identify the swap, should be unique and generated by getRandomBytes
      - lp should be the lp's PublicKey of the swap
      - from should be the user's Keypair and source should be the user's token account of the SPL token
      - use getEscrowAccountAddress and getEscrowAtaTokenAddress to get the escrow and escrowAta offchain
      - mint and tokenProgramId should able to identify the SPL token
    */
    async transferOut(
        uuid: number[],
        lp: PublicKey,
        amount: BN,
        userLock: Lock,
        relayLock: Lock,
        deadline: BN,
        extraData: Buffer,
        from: Keypair,
        source: PublicKey,
        escrow: PublicKey,
        escrowAta: PublicKey,
        mint: PublicKey,
        tokenProgramId: PublicKey
    ): Promise<string> {
        let txHash = await this.program.methods
            .initiate(
                uuid,
                lp,
                amount,
                userLock,
                relayLock,
                deadline,
                extraData
            )
            .accounts({
                payer: this.payer.publicKey,
                from: from.publicKey,
                mint: mint,
                source: source,
                escrow: escrow,
                escrowAta: escrowAta,
                associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
                systemProgram: SystemProgram.programId,
                tokenProgram: tokenProgramId,
            })
            .signers([this.payer, from])
            .rpc();
        return txHash;
    }

    /*
      lp send a SPL token to escrow account, token transfered from lp's token account to escrow's token account
      - uuid identify the swap, should be unique and generated by getRandomBytes
      - user should be the user's PublicKey of the swap
      - from should be the lp's Keypair and source should be the lp's token account of the SPL token
      - use getEscrowAccountAddress and getEscrowAtaTokenAddress to get the escrow and escrowAta offchain
      - mint and tokenProgramId should able to identify the SPL token
    */
    async transferIn(
        uuid: number[],
        user: PublicKey,
        amount: BN,
        lpLock: Lock,
        deadline: BN,
        extraData: Buffer,
        from: Keypair,
        source: PublicKey,
        escrow: PublicKey,
        escrowAta: PublicKey,
        mint: PublicKey,
        tokenProgramId: PublicKey
    ): Promise<string> {
        let txHash = await this.program.methods
            .initiate(
                uuid,
                user,
                amount,
                lpLock,
                null,
                deadline,
                extraData
            )
            .accounts({
                payer: this.payer.publicKey,
                from: from.publicKey,
                mint: mint,
                source: source,
                escrow: escrow,
                escrowAta: escrowAta,
                associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
                systemProgram: SystemProgram.programId,
                tokenProgram: tokenProgramId,
            })
            .signers([this.payer, from])
            .rpc();
        return txHash;
    }

    /*
      user confirm the transferOut, the SPL token transfered from the escrow account to lp's token account
      - uuid should be the same with the uuid used in transferOut
      - preimage is the preimage of the hash lock defined in transferOut
      - destination should be the lp's token account of the SPL token
      - tokenProgramId is the token program id of the SPL token
    */
    async confirmTransferOut(
        uuid: number[],
        preimage: number[],
        destination: PublicKey,
        escrow: PublicKey,
        escrowAta: PublicKey,
        tokenProgramId: PublicKey
    ): Promise<string> {
        let txHash = await this.program.methods
            .confirm(
                uuid,
                preimage
            )
            .accounts({
                destination: destination,
                escrow: escrow,
                escrowAta: escrowAta,
                systemProgram: SystemProgram.programId,
                tokenProgram: tokenProgramId,
            })
            .rpc();
        return txHash;
    }

    /*
      lp confirm the transferIn, the SPL token transfered from the escrow account to user's token account
      - uuid should be the same with the uuid used in transferIn
      - preimage is the preimage of the hash lock defined in transferIn
      - destination should be the user's token account of the SPL token
      - tokenProgramId is the token program id of the SPL token
    */
    async confirmTransferIn(
        uuid: number[],
        preimage: number[],
        destination: PublicKey,
        escrow: PublicKey,
        escrowAta: PublicKey,
        tokenProgramId: PublicKey
    ): Promise<string> {
        let txHash = await this.program.methods
            .confirm(
                uuid,
                preimage
            )
            .accounts({
                destination: destination,
                escrow: escrow,
                escrowAta: escrowAta,
                systemProgram: SystemProgram.programId,
                tokenProgram: tokenProgramId,
            })
            .rpc();
        return txHash;
    }

    /*
      user refund the transferOut, the SPL token transfered from the escrow account to user's token account
      - uuid should be the same with the uuid used in transferOut
      - source should be the user's token account of the SPL token
      - tokenProgramId is the token program id of the SPL token
    */
    async refundTransferOut(
        uuid: number[],
        source: PublicKey,
        escrow: PublicKey,
        escrowAta: PublicKey,
        tokenProgramId: PublicKey
    ): Promise<string> {
        let txHash = await this.program.methods
            .refund(
                uuid
            )
            .accounts({
                source: source,
                escrow: escrow,
                escrowAta: escrowAta,
                systemProgram: SystemProgram.programId,
                tokenProgram: tokenProgramId,
            })
            .rpc();
        return txHash;
    }

    /*
      lp refund the transferIn, the SPL token transfered from the escrow account to lp's token account
      - uuid should be the same with the uuid used in transferIn
      - source should be the lp's token account of the SPL token
      - tokenProgramId is the token program id of the SPL token
    */
    async refundTransferIn(
        uuid: number[],
        source: PublicKey,
        escrow: PublicKey,
        escrowAta: PublicKey,
        tokenProgramId: PublicKey
    ): Promise<string> {
        let txHash = await this.program.methods
            .refund(
                uuid
            )
            .accounts({
                source: source,
                escrow: escrow,
                escrowAta: escrowAta,
                systemProgram: SystemProgram.programId,
                tokenProgram: tokenProgramId,
            })
            .rpc();
        return txHash;
    }
}